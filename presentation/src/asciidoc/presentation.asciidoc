Continuous Delivery - Hands on
==============================
:author:    Oliver Nautsch
:backend:   slidy
:imagesdir: images
:icons:

Ziel
----

* eine Deployment Pipeline bauen

Einführung - Begriffe
---------------------

=== Continuous Delivery ===
bezeichnet eine Sammlung von Techniken, Prozessen und Werkzeugen, die den Softwarelieferprozess verbessern. (Wikipedia)

=== Deployment Pipeline ===
ist eine Menge von Validierungen, die eine Software auf ihrem Weg zur Veröffentlichung bestehen muss. (Wikipedia)

Einführung - Softwareentwicklungsansätze
----------------------------------------

=== Die Manifeste

[width="100%",cols="^4,^1,^4,^1,^4", options="header"]
|===============================================================================================
|Software Craftsmanship      |    |Agile                       |    |Traditionell
|a community of professionals|over|individuals and interactions|over|processes and tools
|well-crafted software       |over|working software            |over|comprehensive documentation
|productive partnerships     |over|customer collaboration      |over|contract negotiation
|steadily adding value       |over|responding to change        |over|following a plan
|===============================================================================================

=== Principles and Practices / Prinzipien und Praktiken

- Prinzipien: sind dem Anderen übergeordnet
- Praktiken: Handlungen die bei der Umsetzung der Prinzipien helfen

Aufgabenstellung
----------------

* ein Bug Tracking Tool - _issumy_
* iterativ entwickeln
* weil wir es alle kennen, oder kennen sollten :)

Git Essentials - Local
----------------------
image::git-logo.png["Git Logo",float="right", link="http://git-scm.com/"]

* +git init+
* +git add <files>+
* +git commit+
* +git reset \-- <files>+
* +git checkout \-- <files>+
* +git status+
* +git log+
Manual::
* +man git-init+
Links::
* Git Buch: http://git-scm.com/book/de
* Visuelle Git Referenz: http://marklodato.github.io/visual-git-guide/index-de.html
* Git CheatSheet: http://ndpsoftware.com/git-cheatsheet.html

Git Essentials - Local - Hands on
---------------------------------

- lege ein Verzeichnis +~/projects/git-ho+ an (+mkdir+, +cd+)
- erzeuge eine Datei +README.asciidoc+ in diesem Verzeichnis und füge den Text "Version 1" und einen Zeilenumbruch ein (+vi+)
- erzeuge ein git repository/git history (+git init+)
- lese output von +git status+
- fuege die Datei zum 'index' hinzu (+git add+)
- +git status+ sagt auch hier was man tuen könnte
- commit in die 'history' fuer diese Datei (+git commit+, erfragt wird +git config+)
- ändere den Inhalt der Datei in dem Du eine Zeile "Version 2" hinzufügst (+vi+)
- mache die Änderung mit der letzten Version in 'history' rückgängig (+git checkout+)
- nochmals die Datei editieren und "Version 3" Zeile hinzufügen
- Datei den 'index' hinzufügen (+git add+)
- 'index' wieder zurücksetzen mit letzter Version in 'history' (+git reset+)
- zum Abschluss noch die History mit allen Änderungen anschauen (+git log+)

Git Essentials - Branching
--------------------------

- +git branch+
  ** erzeugen, auflisten, löschen von Branches
- +git checkout <branch-name>+
  ** wechselt in den branch
  ** setzt _HEAD_ auf den branch
- +git merge+
  ** zusammenführen von Histories
- +git rebase+
  ** erzeugt lineare History in dem Änderungen eines Branches auf einem anderen Branch angewendet werden

Ausflug ins Git-Buch::
- http://git-scm.com/book/de/Git-Branching-Was-ist-ein-Branch%3F[Git Branching - Was ist ein Branch?]

Git Essentials - Branching - Hands on
-------------------------------------

- erzeuge einen neuen Branch "development"
- wechsle auf diesen Branch
- fuege eine neue Zeile mit Text "Branch Development" hinzu
- Änderung commiten
- wechsle in Branch "master"
- kurz anschauen, dass nun in der Datei die gerade gemachte Änderung nicht enhalten ist (z.B. +less README.asciidoc+)
- merge die Änderungen von Branch "development" nun in den Branch "master"
- nun enthält auch der Branch "master" diese Änderung

Git Essentials - Remote
-----------------------

- +git clone+
  ** erzeugt einen Clone eines Repositories in einem neuen Verzeichnis
- +git fetch+
  ** download von Objekten und refs
- +git pull+
  ** fetch und integration in ein anderes Repo oder lokalen Branch
- +git push+
  ** updated remote refs mit lokalen refs indem die notwendigen Objekte geschickt werden


Git Essentials - Remote - hands-on
----------------------------------

- erzeuge ein Verzeichnis +~/git-repos+
- clone +\~/projects/git-ho+ nach +~/git-repos/git-ho.git+ (+git clone \--bare+)
  ** macht ein +git init+ und +git fetch+ ohne eine Arbeitskopie anzulegen
- füge das "Remote-Repository" deinem Lokalen Repository hinzu (+git remote add upstream file://home/dev/git-repos/git-ho.git/+)
- +git remote -v+
- in die Rolle eines 2. Entwickler schlüpfen:
  ** +git clone file:///home/ollin/projects/cd-ws/git-repos/git-ho.git /home/dev/projects/git-ho-dev2+
  ** editiere +README.asciidoc+ in +/home/dev/projects/git-ho-dev2+ (z.B. zusätzliche Zeile "Hallo von Dev2")
  ** commit in History von dev 2
  ** push zum Remote
- wieder in die eigene Rolle schlüpfen
  ** +cd /home/dev/projects/git-ho+
  ** git fetch upstream
  ** git merge upstream/master
  ** fuege eine Zeile "Huhu von Dev1" hinzu und commit, push zu Remote ( -u )
- 2. Entwickler:
  ** +cd /home/dev/projects/git-ho-dev2+
  ** +git pull+
     ** fasst ein _fetch_ und _merge_ zusammen
Optional::
- erzeuge einen Tag "v1" und pushe den Tag ins Remote Repo
- hole den Tag ins lokale Repo des anderen Entwicklers

issumy - Iteration 1
--------------------

- vert.x mit einem "verticle" laufen lassen.

issumy - Iteration 1 - hands-on - install gvm
---------------------------------------------

- installiere GVM the Groovy enVironment Manager http://gvmtool.net/ .

----
~/$curl -s get.gvmtool.net | bash
~/$source "/home/dev/.gvm/bin/gvm-init.sh"
~/$gvm
----

- installiere Gradle http://www.gradle.org/

----
~/$gvm install gradle 2.0
----

- installiere Vert.x http://vertx.io/

----
~/$gvm install vertx 2.1.2
----

- installiere Lazybones Project Creation Tool https://github.com/pledbrook/lazybones

----
~/$gvm install lazybones
----

- erzeuge Projekt mit Schablone aus lazybones

----
~/$mkdir projects && cd projects
~/projects$lazybones create java-basic issumy
~/projects$cd issumy
~/projects/issumy$gradle tasks
----

issumy - Iteration 1 - hands-on - import in IDEA
------------------------------------------------

.Importiere das Projekt in Intellij IDEA
image::iteration1-import-project.png[Import Projekt in IDEA]

issumy - Iteration 1 - hands-on - an example for vert.x
-------------------------------------------------------

[source, Java]
----
package httphelloworld;

/*
 * Copyright 2013 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import org.vertx.java.core.Handler;
import org.vertx.java.core.http.HttpServerRequest;
import org.vertx.java.platform.Verticle;

import java.util.Map;

public class HelloWorldServer extends Verticle {

  public void start() {
    vertx.createHttpServer().requestHandler(new Handler<HttpServerRequest>() {
      public void handle(HttpServerRequest req) {
        req.response().headers().set("Content-Type", "text/plain");
        req.response().end("Hello World");
      }
    }).listen(8080);
  }
}
----
from https://raw.githubusercontent.com/vert-x/vertx-examples/master/src/raw/java/httphelloworld/HelloWorldServer.java

issumy - Iteration 1 - hands-on - running the example for vert.x
----------------------------------------------------------------

- zur Zeit noch keine Abhängigkeiten definiert (Fehler in IDE)
- wir können es auch noch nicht mit gradle bauen
- ... aber vert.x kann schon damit laufen

----
~/projects/issumy$vertx run src/main/java/httphelloworld/HelloWorldServer.java
Succeeded in deploying verticle
----

- öffne den Browser mit +http://localhost:8080/+

.Run Verticle in Browser
image::iteration1-run-helloworld-browser-.png[Run Verticle in Browser]

IMPORTANT: +git commit+

Einführung - vert.x
-------------------
image::vertx-logo.png["Vert.x Logo",float="right", link="http://vertx.io/"]

Vert.x ist ein polyglotes, ereignisorientiertes Anwendungsframework,
das in der Java Virtual Machine läuft.

- Java, JavaScript, Ruby, Python, Groovy, Clojure, Scala
- einfache, mächtige API's zum Schreiben von netzwerkfähigen Appliktationen
- non blocking I/O um viele Verbindungen mit wenigen Threads zu bedienen
- einfaches "actor-like" Programmierungsmodell

Features::

- distributed event bus server to server
- Support für Websockets/SockJS
- einbetten in existierende Java-Applikationen möglich
- Module System via Maven Central, Maven Repository oder Bintray
- Apache Software License 2.0

Einführung - vert.x - Begriffe
------------------------------

- Verticle -- Code welcher von vert.x ausgeführt wird (Vert.x Particle).
- Module   -- eine Vert.x Applikation besteht aus einem oder
mehreren Modulen. Module können mehrere Verticles enthalten. Via modules
kann Funktionalität gekapselt und wiederverwendet werden.
- Concurrency - ein Verticle wird von einem Thread verwendet
- Event Bus - Verticles kommunizieren via dem Event Bus miteinander
- Asynchronous Programming Model - die meiste Zeit werden Event Handler benötigt
- Event Loops - kleine Anzahl von Threads, welche Events an Handler weiterleiten
- Worker Verticles - für blockierenden Code (z.B. JDBC), diese Verticles können
durch unterschiedliche Threads benutzt werden


IMPORTANT: Handler dürfen nicht blockieren

issumy - Iteration 2
--------------------

- einfaches Verticle in Module verpacken

Iteration 2 - Template kopieren
-------------------------------

- clone Template Projekt
- kopiere Notwendiges

[source, bash]
----
~/$cd && cd projects
~/projects$git clone https://github.com/ollin/vertx-gradle-template.git template
~/projects$cp -rf template/gradle issumy/                                     # <1>
~/projects$cp template/build.gradle issumy/                                   # <2>
~/projects$cp template/gradle.properties issumy/
~/projects$cp template/conf.json issumy/                                      # <3>
~/projects$mkdir issumy/src/main/resources/
~/projects$cp template/src/main/resources/mod.json issumy/src/main/resources/ # <4>
~/projects$cp template/gradlew* issumy/                                       # <5>
----
<1> kopiert Gradle Wrapper Libs und Vertx spezifische Build Skripte
<2> kopiert das eigentliche Build Skript und in der nächsten Zeile die Properties zum Build
<3> kopiert Konfigurationsdatei für +gradle runMod+
<4> kopiert die Module-Konfigurationsdatei
<5> kopiert die Gradle Wrapper Skripte

Iteration 2 - +gradle.properties+
---------------------------------

- anpassen der Gradle-Eigenschaften an unser Projekt

[source, conf]
----
# E.g. your domain name
modowner=net.nautsch

# Your module name
modname=issumy

# Your module version
version=0.1-SNAPSHOT

. . .
----


Iteration 2 - +build.gradle+
----------------------------

- anpassen der Artefakt-Eigenschaften an unser Projekt

[source, txt]
----
. . .
def configurePom(def pom) {
  pom.project {
    name rootProject.name
    description 'CH OPEN Workshoptage 2014 - Continuous Delivery - Beispiel Projekt - issumy'
    inceptionYear '2014'
    packaging 'jar'

    url 'https://github.com/ollin/cd-ws-issumy'

    developers {
      developer {
        id 'ollin'
        name 'Oliver Nautsch'
        email 'oliver.nautsch@gmail.com'
      }
    }

    scm {
      url 'https://github.com/ollin/cd-ws-issumy.git'
    }

    licenses {
      license {
        name 'The MIT License (MIT)'
        url 'http://opensource.org/licenses/MIT'
        distribution 'repo'
      }
    }

    properties {
      setProperty('project.build.sourceEncoding', 'UTF8')
    }
  }
}
----

Iteration 2 - running
---------------------

[source, bash]
----
~/projects/issumy$./gradlew tasks

~/projects/issumy$./gradlew fatJar

~/projects/issumy$java -jar build/libs/issumy-0.1-SNAPSHOT-fat.jar #<1>

~/projects/issumy$vertx runzip build/libs/issumy-0.1-SNAPSHOT.zip #<1>

~/projects/issumy$VERTX_MODS=./build/mods bash -c 'vertx runmod net.nautsch~issumy~0.1-SNAPSHOT' #<1>

~/projects/issumy$./gradlew runMod #<1>
----
<1> öffne Browser http://localhost:8080/ , beenden mit CTRL-C

IMPORTANT: +git commit+

Einführung - Gradle
-------------------
image::gradle-logo.png["Gradle Logo",float="right", link="http://www.gradle.org/"]

* Buildskripte heissen *build.gradle*
* ein Buildskript ist ein Groovy-Skript, welche eine eigene DSL benutzt die erweitert oder angepasst werden kann.
* Gradle kennt Plugins
* Konvention vor Konfiguration (Convention over Configuration)
  ** z.B. verwendet das http://www.gradle.org/docs/current/userguide/java_plugin.html[Java-Plugin] das Standard-Verzeichnis-Layout von Maven
* Zwei Phasen der Abarbeitung
  ** Konfiguration -- in der ein _Directed acyclic graph_ (kurz DAG) erzeugt wird, der alle Build-Schritte enthält
  ** Ausführung -- alle Tasks des DAG werden abgearbeitet, wenn vorgängiger Task erfolgreich war
* sowohl deklarativ als auch imperativer Ansatz möglich
* der Gradle-Wrapper
  ** downloaded Gradle und benutzt diese Version
  ** ideal für Continuous Integration, da keine Installation notwendig ist

issumy - Iteration 3
--------------------

- liefere eine Liste von Issues
  ** Annahme: eine Single-Page-Web-App soll geschrieben werden, welche über den EventBus mit dem Server kommuniziert

Iteration 3 - Gradle-Wrapper und Idea
-------------------------------------

image::setting-gradle-wrapper-in-idea.png["Configure Gradle Wrapper in IDEA",float="right"]
- in IDEA -> +File+ -> +Settings+ -> +_gradle_+ (links oben eingeben) -> +Use customizable gradle wrapper+ -> +Apply/Ok+
- IDEA läd nun ein paar Libraries
- erweitere +.gitignore+ wenn notwendig
- ändere Source und Target Version des JDK auf 1.8 in +issumy/gradle/vertx.gradle+
----
...

.idea/
*.iml
----
- Run/Debug aus IDEA
  ** +File+ -> +Project Structure+ -> +Modules+ -> +Dependencies+ -> ändere "provided" in "compile" -> +Ok+
  ** +Run+ -> +Run. . .+ -> +Edit Configurations+ -> + -> +Application+
     *** Name: +vertx runMod issumy+
     *** Main class: +org.vertx.java.platform.impl.cli.Starter+
     *** Program arguments: +runmod net.nautsch\~issumy\~0.1-SNAPSHOT -cp ./build/mods/net.nautsch\~issumy~0.1-SNAPSHOT/+
     *** Working directory: +/home/dev/projects/issumy+
     *** Use classpath of module: +issumy+
     *** +Run+
     *** In der Console muss nun _INFO: Succeeded in deploying module_ erscheinen.
     *** Browser öffnen und +localhost:8080+ liefert wieder _Hello World_


Iteration 3 - Beispiel Programmieren
------------------------------------

* Test
  ** +com.inventage.issumy.issues.test.integration.IssuesViaEventBusTest+
  ** leitet von der abstrakten Klasse +TestVerticle+ ab
  ** überschreibt +start+ um via +container.deployVerticle()+ das Verticle +com.inventage.issumy.issues.IssuesVerticle+ zu deployen
  ** implementiert eine Methode +shouldReturnEmptyListOfIssues+ welche via dem vertx eventBus eine Nachricht an die Adresse +_com.inventage.issumy.issues_+ schickt
     und via einem _replyHandler_ prüft ob ein JsonArray (ist eine vertx-Klasse) mit der Grösse "0" ankommt.

* Implementierung
  ** +com.inventage.issumy.issues.IssuesVerticle+
  ** leitet von der abstrakten Klasse +Verticle+ ab
  ** registriert einen Handler auf dem vertx EventBus mit der Adresse +_com.inventage.issumy.issues_+ welcher einen leeren JsonArray zurückschickt.

Iteration 3 - Test
------------------

[source, java]
----
package com.inventage.issumy.issues.test.integration;

import com.inventage.issumy.issues.IssuesVerticle;
. . .

/**
 * integration test.
 */
public class IssuesViaEventBusTest extends TestVerticle {

    @Test
    public void shouldReturnEmptyListOfIssues() throws Exception {
        // when
        vertx.eventBus().send("com.inventage.issumy.issues", "", (Message<JsonArray> msg) -> {
            // then
            assertThat(msg.body().size(), is(0));
            testComplete();
        });
    }

    @Override
    public void start() {
        initialize();

        container.deployVerticle(IssuesVerticle.class.getName(), event -> {
            if (event.failed()) {
                throw new IllegalStateException("deployment of module failed", event.cause());
            }
            startTests();
        });
    }
}
----

Iteration 3 - Implementierung
-----------------------------
[source, java]
----
package com.inventage.issumy.issues;

import org.vertx.java.core.json.JsonArray;
import org.vertx.java.platform.Verticle;

/**
 * verticle handles issues.
 */
public class IssuesVerticle extends Verticle {

    @Override
    public void start() {
        vertx.eventBus().registerHandler("com.inventage.issumy.issues", event -> {
            event.reply(new JsonArray());
        });

        container.logger().info("IssuesVerticle started");
    }
}
----

* +./gradlew test+
* commit
* push

Einführung - Continous Integration
----------------------------------

http://www.martinfowler.com/articles/continuousIntegration.html[nach Martin Fowler]

* Gemeinsame Codebasis
* Automatisierte Übersetzung
* Kontinuierliche Test-Entwicklung
  ** Test zusammen mit Produktionscode entwickeln
  ** Code Coverage
* Häufige Integration des Codes jedes Entwicklers in den Hauptentwicklungszweig
* Schneller Build und schnelle Test für schnelles Feedback
* Gespiegelte Produktionsumgebung
* Einfacher Zugriff auf Ergebnisse
* Automatisiertes Reporting
* Automatisierte Verteilung

http://de.wikipedia.org/wiki/Kontinuierliche_Integration[Siehe auch Wikipedia - Kontinuierliche Integration]

Einführung - Jenkins
--------------------
image::jenkins_logo.png["Jenkins Logo",float="right", link="http://jenkins-ci.org/"]
Jenkins ist ein erweiterbares, webbasiertes System zur kontinuierlichen Integration. (Siehe http://de.wikipedia.org/wiki/Jenkins_(Software)[Wikipedia])

Begriffe::
* Job (Project)
* Step
* View
* Environment Variable



Zusammenfassung
---------------

* git angefasst
* vert.x ausprobiert
* mit gradle gearbeitet
* eine Deployment Pipeline gebaut
