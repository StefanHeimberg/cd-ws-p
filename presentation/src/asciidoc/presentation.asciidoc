Continuous Delivery - Hands on
==============================
:author:    Oliver Nautsch
:backend:   slidy
:imagesdir: images
:icons:
:toc:

== Zur Person

image::inventage_logo_with_border.gif["Inventage Logo",float="right", link="http://www.inventage.com/"]

Oliver Nautsch

_Subject Matter Expert - Microservices_

Inventage AG, Technoparkstrasse 1, 8005 Zürich

'''

email:      oliver.nautsch@inventage.com +
twitter:    https://twitter.com/ollispieps[@ollispieps] +
github:     https://github.com/ollin[@ollin] +
google+:     https://plus.google.com/+OliverNautsch/[OliverNautsch] +


'''

Jugs Board Member seit 2014 +
#. . . running . . .#


== Ziel


* Einführung in Continuous Delivery
* Bauen einer Deployment Pipeline

== Vorgehen

* Interativ
  ** Einführung in Tool oder Konzept
  ** Hands On
  ** Diskussion
* Folien erstellt mit http://www.methods.co.nz/asciidoc/[Asciidoc] und einsehbar unter +
  https://github.com/ollin/cd-ws-p/blob/master/presentation/src/asciidoc/presentation.asciidoc

== Einführung - Begriffe


=== Continuous Delivery ===
bezeichnet eine Sammlung von Techniken, Prozessen und Werkzeugen,
die den Softwarelieferprozess verbessern. ... Continuous Delivery
wird primär in der Agilen Softwareentwicklung eingesetzt.
(http://de.wikipedia.org/wiki/Continuous_Delivery[Wikipedia])

Continuous Delivery is a software development discipline
where you build software in such a way that the software
can be released to production at any time.
( http://martinfowler.com/bliki/ContinuousDelivery.html[Martin Fowler] )

=== Deployment Pipeline ===
ist eine Menge von Validierungen, die eine Software auf ihrem Weg zur Veröffentlichung bestehen muss. (Wikipedia)

Einführung - Softwareentwicklungsansätze
----------------------------------------

=== Die Manifeste

[width="100%",cols="^4,^1,^4,^1,^4", options="header"]
|===============================================================================================
|Software Craftsmanship      |    |Agile                       |    |Traditionell
|a community of professionals|over|individuals and interactions|over|processes and tools
|well-crafted software       |over|working software            |over|comprehensive documentation
|productive partnerships     |over|customer collaboration      |over|contract negotiation
|steadily adding value       |over|responding to change        |over|following a plan
|===============================================================================================

=== Principles and Practices / Prinzipien und Praktiken

* Prinzipien: sind dem Anderen übergeordnet
* Praktiken: Techniken, Werkzeuge und Handlungen die bei der Umsetzung der Prinzipien helfen
  ** Beispiel: Scrum vs. Kanban.

Aufgabenstellung
----------------

* ein Bug Tracking Tool - _issumy_
* iterativ entwickeln
* weil wir es alle kennen, oder kennen sollten :)

Git Essentials - Local
----------------------
image::git-logo.png["Git Logo",float="right", link="http://git-scm.com/"]

* +git init+
* +git add <files>+
* +git commit+
* +git reset \-- <files>+
* +git checkout \-- <files>+
* +git status+
* +git log+
Manual::
* +man git-init+
Links::
* Git Buch: http://git-scm.com/book/de
* Visuelle Git Referenz: http://marklodato.github.io/visual-git-guide/index-de.html
* Git CheatSheet: http://ndpsoftware.com/git-cheatsheet.html

Git Essentials - Local - Hands on
---------------------------------

- lege ein Verzeichnis +~/projects/git-ho+ an (+mkdir+, +cd+)
- erzeuge eine Datei +README.asciidoc+ in diesem Verzeichnis und füge den Text "Version 1" und einen Zeilenumbruch ein (+vi+)
- erzeuge ein git repository/git history (+git init+)
- lese output von +git status+
- fuege die Datei zum 'index' hinzu (+git add+)
- +git status+ sagt auch hier was man tuen könnte
- commit in die 'history' fuer diese Datei (+git commit+, erfragt wird +git config+)
- ändere den Inhalt der Datei in dem Du eine Zeile "Version 2" hinzufügst (+vi+)
- mache die Änderung mit der letzten Version in 'history' rückgängig (+git checkout+)
- nochmals die Datei editieren und "Version 3" Zeile hinzufügen
- Datei den 'index' hinzufügen (+git add+)
- 'index' wieder zurücksetzen mit letzter Version in 'history' (+git reset+)
- zum Abschluss noch die History mit allen Änderungen anschauen (+git log+)

Git Essentials - Branching
--------------------------

- +git branch+
  ** erzeugen, auflisten, löschen von Branches
- +git checkout <branch-name>+
  ** wechselt in den branch
  ** setzt _HEAD_ auf den branch
- +git merge+
  ** zusammenführen von Histories
- +git rebase+
  ** erzeugt lineare History in dem Änderungen eines Branches auf einem anderen Branch angewendet werden

Ausflug ins Git-Buch::
- http://git-scm.com/book/de/Git-Branching-Was-ist-ein-Branch%3F[Git Branching - Was ist ein Branch?]

Git Essentials - Branching - Hands on
-------------------------------------

- erzeuge einen neuen Branch "development"
- wechsle auf diesen Branch
- fuege eine neue Zeile mit Text "Branch Development" hinzu
- Änderung commiten
- wechsle in Branch "master"
- kurz anschauen, dass nun in der Datei die gerade gemachte Änderung nicht enhalten ist (z.B. +less README.asciidoc+)
- merge die Änderungen von Branch "development" nun in den Branch "master"
- nun enthält auch der Branch "master" diese Änderung

Git Essentials - Remote
-----------------------

- +git clone+
  ** erzeugt einen Clone eines Repositories in einem neuen Verzeichnis
- +git fetch+
  ** download von Objekten und refs
- +git pull+
  ** fetch und integration in ein anderes Repo oder lokalen Branch
- +git push+
  ** updated remote refs mit lokalen refs indem die notwendigen Objekte geschickt werden


== Git Essentials - Remote - hands-on

* erzeuge ein Verzeichnis +~/git-repos+
* clone +\~/projects/git-ho+ nach +~/git-repos/git-ho.git+ (+git clone \--bare+)
  ** macht ein +git init+ und +git fetch+ ohne eine Arbeitskopie anzulegen
* füge das "Remote-Repository" deinem Lokalen Repository hinzu (+git remote add upstream file:///home/dev/git-repos/git-ho.git+)
* +git remote -v+
* in die Rolle eines 2. Entwickler schlüpfen:
  ** +git clone file:///home/ollin/projects/cd-ws/git-repos/git-ho.git /home/dev/projects/git-ho-dev2+
  ** editiere +README.asciidoc+ in +/home/dev/projects/git-ho-dev2+ (z.B. zusätzliche Zeile "Hallo von Dev2")
  ** commit in History von dev 2
  ** push zum Remote
* wieder in die eigene Rolle schlüpfen
  ** +cd /home/dev/projects/git-ho+
  ** git fetch upstream
  ** git merge upstream/master
  ** fuege eine Zeile "Huhu von Dev1" hinzu und commit, push zu Remote ( -u )
* 2. Entwickler:
  ** +cd /home/dev/projects/git-ho-dev2+
  ** +git pull+
     ** fasst ein _fetch_ und _merge_ zusammen
* erzeuge einen Tag "v1" und pushe den Tag ins Remote Repo
* hole den Tag ins lokale Repo des anderen Entwicklers

== issumy - Iteration 1

- vert.x mit einem "verticle" laufen lassen.

== issumy - Iteration 1 - hands-on - install gvm


* installiere http://gvmtool.net/[GVM] the Groovy enVironment Manager.

----
~/$curl -s get.gvmtool.net | bash
~/$source "/home/dev/.gvm/bin/gvm-init.sh"
~/$gvm
----

* installiere http://www.gradle.org/[Gradle]

----
~/$gvm install gradle 1.10
----

* installiere http://vertx.io/[Vert.x]

----
~/$gvm install vertx 2.1.2
----

* installiere https://github.com/pledbrook/lazybones[Lazybones Project Creation Tool]

----
~/$gvm install lazybones
----

* erzeuge Projekt mit Schablone aus lazybones

----
~/$mkdir projects && cd projects
~/projects$lazybones create java-basic issumy
~/projects$cd issumy
~/projects/issumy$gradle tasks
----

== issumy - Iteration 1 - hands-on - import in IDEA

.Importiere das Projekt in Intellij IDEA
image::iteration1-import-project.png[Import Projekt in IDEA]

== issumy - Iteration 1 - hands-on - an example for vert.x

[CAUTION]
Die https://github.com/vert-x/vertx-examples[Beispiele von vertx] sind Apache License, Version 2.0 lizenziert. Aus Gründen
der Übersicht sind die entsprechenden Header entfernt.

[source, Java]
----
package httphelloworld;

import org.vertx.java.core.Handler;
import org.vertx.java.core.http.HttpServerRequest;
import org.vertx.java.platform.Verticle;

import java.util.Map;

public class HelloWorldServer extends Verticle {

  public void start() {
    vertx.createHttpServer().requestHandler(new Handler<HttpServerRequest>() {
      public void handle(HttpServerRequest req) {
        req.response().headers().set("Content-Type", "text/plain");
        req.response().end("Hello World");
      }
    }).listen(8080);
  }
}
----
from https://raw.githubusercontent.com/vert-x/vertx-examples/master/src/raw/java/httphelloworld/HelloWorldServer.java

- zur Zeit noch keine Abhängigkeiten definiert (Fehler in IDE)
- wir können es auch noch nicht mit gradle bauen
- aber . . .

issumy - Iteration 1 - hands-on - running the example for vert.x
----------------------------------------------------------------

- . . . vert.x kann schon damit laufen

----
~/projects/issumy$vertx run src/main/java/httphelloworld/HelloWorldServer.java
Succeeded in deploying verticle
----

- öffne den Browser mit +http://localhost:8080/+

.Run Verticle in Browser
image::iteration1-run-helloworld-browser-.png[Run Verticle in Browser]

Anlegen locales und remote Repostory::

Datei +~/projects/issumy/.gitignore+ anlegen und folgendes einfügen

[source, txt]
----
.gradle/
.idea/
*.iml
build
----

[source, bash]
----
cd  ~/projects/issumy
git init
git add .
git commit -m "initial"
git clone --bare . ~/git-repos/issumy.git
git remote add upstream file:///home/dev/git-repos/issumy.git/
git fetch upstream
git branch -u upstream/master master
----


Einführung - vert.x
-------------------
image::vertx-logo.png["Vert.x Logo",float="right", link="http://vertx.io/"]

Vert.x ist ein polyglotes, ereignisorientiertes Anwendungsframework,
das in der Java Virtual Machine läuft.

- Java, JavaScript, Ruby, Python, Groovy, Clojure, Scala
- einfache, mächtige API's zum Schreiben von netzwerkfähigen Appliktationen
- non blocking I/O um viele Verbindungen mit wenigen Threads zu bedienen
- einfaches "actor-like" Programmierungsmodell

Features::

- distributed event bus server to server
- Support für Websockets/SockJS
- einbetten in existierende Java-Applikationen möglich
- Module System via Maven Central, Maven Repository oder Bintray
- Apache Software License 2.0

Einführung - vert.x - Begriffe
------------------------------

- Verticle -- Code welcher von vert.x ausgeführt wird (Vert.x Particle).
- Module   -- eine Vert.x Applikation besteht aus einem oder
mehreren Modulen. Module können mehrere Verticles enthalten. Via modules
kann Funktionalität gekapselt und wiederverwendet werden.
- Concurrency - ein Verticle wird von einem Thread verwendet
- Event Bus - Verticles kommunizieren via dem Event Bus miteinander
- Asynchronous Programming Model - die meiste Zeit werden Event Handler benötigt
- Event Loops - kleine Anzahl von Threads, welche Events an Handler weiterleiten
- Worker Verticles - für blockierenden Code (z.B. JDBC), diese Verticles können
durch unterschiedliche Threads benutzt werden


IMPORTANT: Handler dürfen nicht blockieren

issumy - Iteration 2
--------------------

- einfaches Verticle in Module verpacken

Iteration 2 - Template kopieren
-------------------------------

- clone Template Projekt
- kopiere Notwendiges

[source, bash]
----
cd && cd projects
git clone https://github.com/ollin/vertx-gradle-template.git template
cp -rf template/gradle issumy/                                     # <1>
cp template/build.gradle issumy/                                   # <2>
cp template/gradle.properties issumy/
cp template/conf.json issumy/                                      # <3>
mkdir issumy/src/main/resources/
cp template/src/main/resources/mod.json issumy/src/main/resources/ # <4>
cp template/gradlew* issumy/                                       # <5>
----
<1> kopiert Gradle Wrapper Libs und Vertx spezifische Build Skripte
<2> kopiert das eigentliche Build Skript und in der nächsten Zeile die Properties zum Build
<3> kopiert Konfigurationsdatei für +gradle runMod+
<4> kopiert die Module-Konfigurationsdatei
<5> kopiert die Gradle Wrapper Skripte

Iteration 2 - +gradle.properties+
---------------------------------

- anpassen der Gradle-Eigenschaften an unser Projekt

[source, conf]
----
# E.g. your domain name
modowner=net.nautsch

# Your module name
modname=issumy

# Your module version
version=0.1-SNAPSHOT

. . .
----


Iteration 2 - +build.gradle+
----------------------------

- anpassen der Artefakt-Eigenschaften an unser Projekt

[source, txt]
----
. . .
def configurePom(def pom) {
  pom.project {
    name rootProject.name
    description 'CH OPEN Workshoptage 2014 - Continuous Delivery - Beispiel Projekt - issumy'
    inceptionYear '2014'
    packaging 'jar'

    url 'https://github.com/ollin/cd-ws-issumy'

    developers {
      developer {
        id 'ollin'
        name 'Oliver Nautsch'
        email 'oliver.nautsch@gmail.com'
      }
    }

    scm {
      url 'https://github.com/ollin/cd-ws-issumy.git'
    }

    licenses {
      license {
        name 'The MIT License (MIT)'
        url 'http://opensource.org/licenses/MIT'
        distribution 'repo'
      }
    }

    properties {
      setProperty('project.build.sourceEncoding', 'UTF8')
    }
  }
}
----

Iteration 2 - running
---------------------

Definiere in +mod.json+ die Klasse +httphelloworld.HelloWorldServer+ als _main_

[source, bash]
----
~/projects/issumy$./gradlew tasks

~/projects/issumy$./gradlew fatJar
----
starten via:

[source, bash]
----
~/projects/issumy$java -jar build/libs/issumy-0.1-SNAPSHOT-fat.jar #<1>
----
oder

[source, bash]
----
~/projects/issumy$vertx runzip build/libs/issumy-0.1-SNAPSHOT.zip #<1>
----
oder

[source, bash]
----
~/projects/issumy$VERTX_MODS=./build/mods bash -c 'vertx runmod net.nautsch~issumy~0.1-SNAPSHOT' #<1>
----
oder

[source, bash]
----
~/projects/issumy$./gradlew runMod #<1>
----

<1> öffne Browser http://localhost:8080/ , beenden mit CTRL-C

IMPORTANT: +git commit+

Einführung - Gradle
-------------------
image::gradle-logo.png["Gradle Logo",float="right", link="http://www.gradle.org/"]

* Buildskripte heissen *build.gradle*
* ein Buildskript ist ein Groovy-Skript, welche eine eigene DSL benutzt die erweitert oder angepasst werden kann.
* Gradle kennt Plugins
* Konvention vor Konfiguration (Convention over Configuration)
  ** z.B. verwendet das http://www.gradle.org/docs/current/userguide/java_plugin.html[Java-Plugin] das Standard-Verzeichnis-Layout von Maven
* Zwei Phasen der Abarbeitung
  ** Konfiguration -- in der ein _Directed acyclic graph_ (kurz DAG) erzeugt wird, der alle Build-Schritte enthält
  ** Ausführung -- alle Tasks des DAG werden abgearbeitet, wenn vorgängiger Task erfolgreich war
* sowohl deklarativ als auch imperativer Ansatz möglich
* der Gradle-Wrapper
  ** downloaded Gradle und benutzt diese Version
  ** ideal für Continuous Integration, da keine Installation notwendig ist

== issumy - Iteration 3 - Implementiere "liefere Liste"


* liefere eine Liste von Issues
  ** Annahme:
     *** eine Single-Page-Web-App wird von einem anderen Team geschrieben,
     *** wir implementieren den REST-Endpunkt auf der Serverseite
     *** Intern soll der REST Endpunkt über den Event Bus kommunizieren

== Iteration 3 - Gradle-Wrapper und Idea


image::setting-gradle-wrapper-in-idea.png["Configure Gradle Wrapper in IDEA",float="right"]
- in IDEA -> +File+ -> +Settings+ -> +_gradle_+ (links oben eingeben) -> +Use customizable gradle wrapper+ -> +Apply/Ok+
- IDEA läd nun ein paar Libraries
- erweitere +.gitignore+ wenn notwendig
----
...

.idea/
*.iml
----
- ändere Source und Target Version des JDK auf 1.8 in +issumy/gradle/vertx.gradle+
- Run/Debug aus IDEA
  ** +File+ -> +Project Structure+ -> +Modules+ -> +Dependencies+ -> ändere "provided" in "compile" -> +Ok+
  ** +Run+ -> +Run. . .+ -> +Edit Configurations+ -> + -> +Application+
     *** Name: +vertx runMod issumy+
     *** Main class: +org.vertx.java.platform.impl.cli.Starter+
     *** Program arguments: +runmod net.nautsch\~issumy\~0.1-SNAPSHOT -cp ./build/mods/net.nautsch\~issumy~0.1-SNAPSHOT/+
     *** Working directory: +/home/dev/projects/issumy+
     *** Use classpath of module: +issumy+
     *** +Run+
     *** In der Console muss nun _INFO: Succeeded in deploying module_ erscheinen.
     *** Browser öffnen und +localhost:8080+ liefert wieder _Hello World_


== Iteration 3 - Beispiel Programmieren

image::i3-issumy-issues.png["Übersicht Implementierung Iteration 3", float="right"]

via Rest::

* Test
  ** +com.inventage.issumy.issues.test.integration.IssuesViaRestTest+
    *** leitet von der abstrakten Klasse +TestVerticle+ ab
    *** implementiert eine Methode +shouldReturnEmptyListOfIssues+ welche via +vertx.createHttpClient+ ein GET an die Adresse +_/issues_+ schickt
        und via einem _responseHandler_ prüft ob ein leerer JSON String geliefert wird.
    *** überschreibt +start+ um via +container.deployVerticle()+ das Verticle +com.inventage.issumy.issues.IssuesStarterVerticle+ zu deployen


* Implementierung
  ** +com.inventage.issumy.issues.IssuesRestVerticle+
    *** konfiguriert einen +RouteMatcher+ der auf ein GET reagiert mit dem Pattern +_/issues_+
    *** der RouteMatcher hört via +vertx.createHttpServer().requestHandler( . . . + an Port +8080+ und delegiert den Aufruf via EventBus
        an "com.inventage.issumy.issues"
  ** +com.inventage.issumy.issues.IssuesStarterVerticle+
    *** deployed die Verticles +IssuesRestVerticle+ und +IssuesVerticle+
  ** +mod.json+
    *** definiert +IssuesStarterVerticle+ als +main+

via EventBus::

* Test (Optional)
  ** +com.inventage.issumy.issues.test.integration.IssuesViaEventBusTest+
  ** leitet von der abstrakten Klasse +TestVerticle+ ab
  ** überschreibt +start+ um via +container.deployVerticle()+ das Verticle +com.inventage.issumy.issues.IssuesVerticle+ zu deployen
  ** implementiert eine Methode +shouldReturnEmptyListOfIssues+ welche via dem vertx eventBus eine Nachricht an die Adresse +_com.inventage.issumy.issues_+ schickt
     und via einem _replyHandler_ prüft ob ein JsonArray (ist eine vertx-Klasse) mit der Grösse "0" ankommt.

* Implementierung
  ** +com.inventage.issumy.issues.IssuesVerticle+
  ** leitet von der abstrakten Klasse +Verticle+ ab
  ** registriert einen Handler auf dem vertx EventBus mit der Adresse +_com.inventage.issumy.issues_+ welcher einen leeren JsonArray zurückschickt.

== Iteration 3 - Beispiel für Test  via EventBus

[source, java]
----
package com.inventage.issumy.issues.test.integration;

import com.inventage.issumy.issues.IssuesVerticle;
. . .

/**
 * integration test.
 */
public class IssuesViaEventBusTest extends TestVerticle {

    @Test
    public void shouldReturnEmptyListOfIssues() throws Exception {
        // when
        vertx.eventBus().send("com.inventage.issumy.issues", "", (Message<JsonArray> msg) -> {
            // then
            assertThat(msg.body().size(), is(0));
            testComplete();
        });
    }

    @Override
    public void start() {
        initialize();

        container.deployVerticle(IssuesVerticle.class.getName(), event -> {
            if (event.failed()) {
                throw new IllegalStateException("deployment of module failed", event.cause());
            }
            startTests();
        });
    }
}
----

== Iteration 3 - Beispiel für Implementierung via EventBus

[source, java]
----
package com.inventage.issumy.issues;

import org.vertx.java.core.json.JsonArray;
import org.vertx.java.platform.Verticle;

/**
 * verticle handles issues.
 */
public class IssuesVerticle extends Verticle {

    @Override
    public void start() {
        vertx.eventBus().registerHandler("com.inventage.issumy.issues", event -> {
            event.reply(new JsonArray());
        });

        container.logger().info("IssuesVerticle started");
    }
}
----

* +./gradlew test+
* commit
* erzeuge remote repository mit +file://+ Protokoll unter ~/repos/

Einführung - Continous Integration
----------------------------------

http://www.martinfowler.com/articles/continuousIntegration.html[nach Martin Fowler]

* Gemeinsame Codebasis
* Automatisierte Übersetzung
* Kontinuierliche Test-Entwicklung
  ** Test zusammen mit Produktionscode entwickeln
  ** Code Coverage
* Häufige Integration des Codes jedes Entwicklers in den Hauptentwicklungszweig
* Schneller Build und schnelle Test für schnelles Feedback
* Gespiegelte Produktionsumgebung
* Einfacher Zugriff auf Ergebnisse
* Automatisiertes Reporting
* Automatisierte Verteilung

http://de.wikipedia.org/wiki/Kontinuierliche_Integration[Siehe auch Wikipedia - Kontinuierliche Integration]

Einführung - Jenkins
--------------------
image::jenkins_logo.png["Jenkins Logo",float="right", link="http://jenkins-ci.org/"]
Jenkins ist ein erweiterbares, webbasiertes System zur kontinuierlichen Integration. (Siehe http://de.wikipedia.org/wiki/Jenkins_(Software)[Wikipedia])

Begriffe::
* Jobs (Projects)
* Steps
* Post-build Actions
* Views
* https://wiki.jenkins-ci.org/display/JENKINS/Building+a+software+project#Buildingasoftwareproject-JenkinsSetEnvironmentVariables[Environment Variable]
* https://wiki.jenkins-ci.org/display/JENKINS/Plugins[Plugin]
  ** Beispiele:
     *** https://wiki.jenkins-ci.org/display/JENKINS/Conditional+BuildStep+Plugin[Conditional BuildStep Plugin]
     *** https://wiki.jenkins-ci.org/display/JENKINS/Git+Plugin[Git Plugin]

issumy - Iteration 4 - automatisiertes Testen
---------------------------------------------

* automatisiere das Testen mit Jenkins
  ** Plugins installieren
  ** Job/Projekt erzeugen

Iteration 4 - Anlegen eines Jobs
--------------------------------

* Jenkins Admin Konsole im Browser öffnen: http://localhost:8180 (im Firefox ist auch ein Bookmark)
* installiere Jenkins-Plugins:
  ** "SafeRestart Plugin"
  ** "Git Plugin"
  ** "Gradle plugin"
  ** "JaCoCo Plugin"
  ** "EnvInject Plugin (Environment Injector Plugin)"
  ** "Build Environment Plugin"
  ** "Build Pipeline Plugin"
  ** "Authorize Project plugin"
* erzeuge ein free-style software project "issumy-stage-commit"
  ** Source Code Mangement - Git
     *** checkout von +file:///home/dev/git-repos/issumy.git+
     *** baue von +*/master+
  ** "Add Build Step"
     ** Rufe das Gradle Script auf
     *** benutze den Gradle Wrapper
     *** Task: _test_
* Job laufen lassen
  ** via Button im GUI
  ** via URL im Browser ( http://localhost:8180/job/issumy-stage-commit/build )
  ** via URL auf Command Line ( +curl http://localhost:8180/job/issumy-stage-commit/build+ )

Einführung - Nexus
------------------

Nexus ist ein Software Repository Manager. Ein Softwarerepository ist ein Speicherort von
welchen man Softwarepakete beziehen kann. Es enthält neben den Programmpaketen auch Metadaten über diese.

Begriffe::
* Repository
  ** Hosted
  ** Proxy
  ** Group
* User
* Rollen


issumy - Iteration 5 - Artefakte speichern
------------------------------------------

* liefere die Artefakte von _issumy_ ins Repository "Snapshots"
notwendige Schritte:
* anmelden in Nexus ( http://localhost:8181/nexus user: +admin+ password: +admin123+ )
* finde die URL's fuer die Repositories
  ** Release
  ** Snapshot
* setze Passwort fuer User "deployment" auf "deployment9"
* erzeuge einen Task "uploadArchives" in gradle am Ende von +build.gradle+
* commit / push
* erzeuge in Jenkins einen neuen "build step" innerhalb von "issumy-stage-commit"
  ** mit gradle wrapper
  ** und task "uploadArchives"
* Job starten
* Nexus - Inhalt von Repository "Snapshots" prüfen

Iteration 5 - uploadArchives
----------------------------

+build.gradle+
[source, txt]
----
...
uploadArchives {
    repositories {
        mavenDeployer {
            repository(url: "http://localhost:8181/nexus/content/repositories/releases/") {
                authentication(
                        userName: "deployment",
                        password: "deployment9"
                )
            }
            snapshotRepository(url: "http://localhost:8181/nexus/content/repositories/snapshots/") {
                authentication(
                        userName: "deployment",
                        password: "deployment9"
                )
            }
        }
    }
}
----

Iteration 5 - Diskussion
------------------------

* URLs
  ** +http://localhost:8181/nexus/content/repositories/releases/+
  ** +http://localhost:8181/nexus/content/repositories/snapshots/+
* Warum sollte man die Passwörter aus +build.gradle+ auslagern?
* Wie finde komme ich selber auf die Lösung von "uploadArchives"?
  ** Dokumentation Maven Plugin ( http://www.gradle.org/docs/current/userguide/maven_plugin.html#uploading_to_maven_repositories )
  ** DSL Reference ( http://www.gradle.org/docs/current/dsl/ )
* "... can be released to production at any time." -> also jeder Commit.
* Automate everything!

== issumy - Iteration 6 - Hooks

* automatisiere das Starten des Jenkins Jobs bei jedem Commit
* benutze dazu "Hooks" von git

empfohlenes Vorgehen::
* das Git-Plugin von Jenkins unterstützt spezielle URL's um Jobs zu starten welche das Repository benutzen
  ** finde heraus, wie diese aussehen
  ** benutze die Url via CLI (wenn +Scheduled polling of issumy-stage-commit+ zu sehen ist, dann ist die URL und Konfiguration in Jenkins richtig)
     *** Polling in Jenkins ohne Schedule muss aktiviert sein
     *** Der Job startet nur, wenn wirklich eine Änderung im Repository gemacht wurde
* Git stellt clientseitige und serverseitige Hooks zur Verfügung
  ** finde den Hook der ausgeführt wird, wenn der _push_ auf dem Server erfolgreich war
  ** erzeuge die entsprechende Datei und mache sie mit chmod +x ausführbar

== Iteration 6 - Lösungsbeispiel

image::jenkins-git-poll.png["Poll markieren",float="right"]

Datei: +/home/dev/git-repos/issumy.git/hooks/post-receive+

[source, bash]
----
#!/bin/bash
curl http://localhost:8180/git/notifyCommit?url=file:///home/dev/git-repos/issumy.git

----

IMPORTANT: +chmod +x /home/dev/git-repos/issumy.git/hooks/post-receive+

== Iteration 6 - Diskussion

* Warum ist der Hook via Repository besser als via Projektnamen?

nächster Schritt::

* Gespiegelte Produktionsumgebung

== Einführung - Docker

image::docker_logo.png["Docker Logo",float="right", link="https://www.docker.com/"]

Docker is an open platform for developers and sysadmins to build, ship, and run distributed applications.

Bestandteile::

* https://docs.docker.com/installation/ubuntulinux/[Docker Engine]
* https://hub.docker.com/[Docker Hub]

Techniken::

* cgroups - control groups - Linux Kernel Funktion zum begrenzen, messen und isolieren von
  Ressourcen (CPU, Speicher, disc I/O etc.)
* kernel namespaces - trennen der Sichtbarkeit von Ressourcen
  in anderen Gruppen (Prozesse, Netzwerk, user IDs, Dateisysteme, etc.)
* Overlay-Dateisystem (AuFS oder Btrfs)

Wer steht hinter Docker::

* die Firma Docker (Anfangs Jahr 15 Millionen US-Doller erhalten)
* Red Hat integriert Docker in Red Hat Enterprise Linux 7 und will Container zertifizieren
* Google, Microsoft, Red Hat, IBM, Docker, Mesosphere, CoreOS und SaltStack
  arbeiten am https://github.com/GoogleCloudPlatform/kubernetes[Kubernetes Projekt] mit.

Begriffe::

* Image
* Container
* Registry
  * Hub
  * local eigene

== Docker Kommandos

image::dockerstory.png["Docker Story",float="right"]

* +man docker+

* +docker images+    listed die Images auf
* +docker run+       führt ein Kommando in einem neuen Container aus
* +docker stop+      stopt einen Container
* +docker start+     startet einen Container
* +docker ps+        listed die Container auf
* +docker rm+        löscht Container

* +docker build+     erzeugt ein neues Image aus einem _Dockerfile_
* +docker pull+      zieht ein Image oder Repository von Registry
* +docker push+      schiebt ein Image oder Repository zur Registry
* +docker rmi+       löscht Image

* +docker inspect+   Infos über Container oder Images

== Docker -  Erzeugen eines Containers

[source, bash]
----
docker run -i -t ubuntu:14.04.1 bash
root@1081f6156ecc:/#exit
docker ps -a
docker ps -a
CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS                      PORTS               NAMES
4133bbfc2eaa        ubuntu:14.04.1      "bash"                 12 seconds ago      Exited (0) 10 seconds ago                       trusting_davinci
. . .
----

[source, bash]
----
docker run --rm -i -t ubuntu:14.04.1 bash
root@35d2e9236656:/# exit
docker ps -a
----

[source, bash]
----
docker run --rm -i -t ubuntu:14.04.1 ls -al
----

== Docker - Erzeugen eines Image

=== via commit

[source, bash]
----
docker run -t -i  ubuntu:14.04.1 bash
root@dcde95ca3e5c:/# touch huschihops.txt
root@dcde95ca3e5c:/# exit
docker ps -a
docker commit -m="added huschihops.txt" -a="Oliver Nautsch" dcde95ca3e5c inventage/huschihops:1.0
----

=== via Dockerfile

erzeuge +~/projects/docker-test/Dockerfile+

[source, txt]
----
FROM ubuntu:14.04.1
MAINTAINER Oliver Nautsch <oliver.nautsch@gmail.com>

RUN touch huschihops.txt
----

[source, bash]
----
docker build -t ollin/huschihops:v2 .
Sending build context to Docker daemon  2.56 kB
Sending build context to Docker daemon
Step 0 : FROM ubuntu:14.04.1
 ---> c4ff7513909d
Step 1 : MAINTAINER Oliver Nautsch <oliver.nautsch@gmail.com>
 ---> Using cache
 ---> 98658a58fa03
Step 2 : RUN touch huschihops.txt
 ---> Running in 2d4d554cbf2a
 ---> 01ee073272ec
Removing intermediate container 2d4d554cbf2a
Successfully built 01ee073272ec

docker images
REPOSITORY                       TAG                   IMAGE ID            CREATED             VIRTUAL SIZE
ollin/huschihops                 v2                    01ee073272ec        31 seconds ago      225.4 MB
. . .
----


== Erzeugen eines Images - hands on

via docker commit::

* erzeuge ein Image "inventage/huschihops:1.0" welches eine leere Datei +huschihops.txt+ enthält

via Dockerfile::

* erzeuge ein Image "inventage/huschihops:2.0" mittels einer Datei +~/projects/docker-test/Dockerfile+

== Einführung - Eigene Docker Registry

[source, bash]
----
docker run -p 5000:5000 -dt --name registry registry
docker run -d -p 5001:8080 --name registry-ui atcol/docker-registry-ui
docker ps
----

* nun kann man den Browser mit http://localhost:8080/ öffnen
  und die Applikation _Docker Registry Web_ sehen

== Iteration 8 - Veröffentlichen eines Images - Teil 1

* Konfiguriere das Repository, welches auf Port 5000 im docker-host läuft
  im _Docker Registry Web_
  * benutze +ifconfig+ im docker host um die richtige IP-Adresse zu finden
* tagge die das Image für das lokale Repository mit +1.0+ und +latest+
* und schiebe die Images ins lokale Repo
* prüfe das Ergebnis im _Docker Registry Web_

[source, bash]
----
docker tag inventage/huschihops:2.0 localhost:5000/inventage/huschihops:2.0
docker tag inventage/huschihops:2.0 localhost:5000/inventage/huschihops:latest
docker images #zeigt nun schön, dass die Tags *latest* und *2.0* auf die gleiche image id zeigen

docker push localhost:5000/inventage/huschihops:2.0
docker push localhost:5000/inventage/huschihops:latest
----

== Iteration 8 - Veröffentlichen eines Images via gradle - Teil 2

* integriere dieses Taggen und Pushen in gradle build von issumy
* es muss ein _Dockerfile_ mit einem Task _createDockerfile_ erzeugt werden:
[source, txt]
----
FROM ollin/vertx")
MAINTAINER Oliver Nautsch <oliver.nautsch@gmail.com>")

VOLUME /home/issumy
ADD $modZip.archiveName /home/issumy/$modZip.archiveName
EXPOSE 8080

WORKDIR /home/issumy
CMD ["runzip", "$modZip.archiveName"]
----

    *** dieses Dockerfile zusammen mit der mod-zip datei ins Image stellen
    *** dann Docker-Image erstellen

[source, java]
----
task createDockerImage (type: Exec) {
    workingDir 'build/docker'
    commandLine 'docker', 'build', '-t', "inventage/issumy:$version", '.'
}
createDockerImage.dependsOn createDockerfile, prepareModZipForDocker
----

   *** docker tag mit +localhost:5000/inventage/issumy:latest+ und +localhost:5000/inventage/issumy:$version+
   *** docker push mit +localhost:5000/inventage/issumy:latest+ und +localhost:5000/inventage/issumy:$version+
   *** _uploadArchives_ abhängig machen von den push tasks
   *** damit _jenkins_ den _docker_ daemon benutzen darf, auf der Kommandozeile:

[source, bash]
----
sudo useradd -G docker jenkins
sudo service jenkins restart
----

== Continuous Delivery - Prinzipien

image::book-continuous-delivery.jpg["Buch - Continuous Delivery",float="right"]

* zuverlässnger und wiederholbarer Prozess zum Releasen von Software
* Automatisiere alles!
* Wenn etwas mühsam oder schwierig ist, dann mache es noch öfter!
* Alles in Versionskontrolle.
* Done meint _Released_
* Baue Qualität ein!
* Jeder ist für dem Release Prozess verantwortlich.

== Continuous Delivery - Praktiken

* Baue Binaries nur ein Mal.
* Benutze den genau den gleichen Mechanismus für die Auslieferung in jede Umgebung.
* _Smoke test_ nach der Auslieferung.
* Wenn etwas schiefgeht, stoppe die Pipeline.

== Die Versionsnummer

* http://semver.org/[Semantic Versioning]
  ** MAJOR
  ** MINOR
  ** PATCH
* Jeder Commit ist ein potentieller Release!
  ** Kein SNAPSHOT in der Pipeline!
  ** Entwickler arbeiten aber auf einem Snapshot.
* ein Kompromiss wie es z.B. http://freecode.com/projects/h2/releases[H2] macht  (1.3.176, 1.4.177)

== Iteration 9 - Integriere Versionsnummer in gradle

* erzeuge eine Datei +~/dev/issumy/version.properties+ mit folgendem Inhalt
[source, txt]
----
APP_VERSION_PREFIX=1.0
----
* entferne die folgenden Zeilen aus +gradle.properties+
[source, txt]
----
# Your module version
version=0.1-SNAPSHOT
----
* Weise in Jenkins im Job "issumy-stage-commit" der Variablen +PIPE_FLOW_NUMBER+ die Nummer des Builds zu
  (ist eine Jenkins https://wiki.jenkins-ci.org/display/JENKINS/Building+a+software+project#Buildingasoftwareproject-JenkinsSetEnvironmentVariables[Umgebungsvariable])
* implementiere eine Methode +readVersion+ in gradle.build welche eine Versionsnummer liefert
  ** liesst +version.properties+
  ** extrahiert den Prefix (+APP_VERSION_PREFIX+) daraus
  ** liesst +PIPE_FLOW_NUMBER+ aus Umgebung aus
  ** das Ergebnis ist:
    *** "1.0-SNAPSHOT" wenn keine +PIPE_FLOW_NUMBER+ gefunden wird
    *** sonst "1.0.56"
* weise das Erbnis dieser Methode der Variablen +version+ in der ersten Zeile von +build.gradle+ zu

== Iteration 10 - stage-production

* erzeuge eine Datei +~/projects/issumy/stage.production/build.gradle mit Wrapper und folgenden Tasks:
  ** +stopProductionContainer+
  ** +removeProductionContainer+ abhängig von +stopProductionContainer+
  ** +deployProduction+ abhängig von +removeProductionContainer+
    *** soll +docker run+ benutzen um mit der Umgebungsvariablen +APP_VERSION+ das Image mit der aktuellen Version laufen zu lassen
    *** Name des Containers: "issumy-production"
* teste auf der Command Line
* erzeuge einen Jenkins Job _issumy-stage-production_ welcher *manuell* nach _issumy-stage-commit_ gestartet werden soll
  ** folgende Variablen von _issumy-stage-commit_ nach _issumy-stage-production_ übergeben
    *** übergebe die Git-Commit Nummer als +GIT_STAGE_COMMIT+
    *** übergebe die Variable +APP_VERSION+ (bestehend aus +<APP_VERSION_PREFIX>.<PIPE_FLOW_NUMBER>+)
  ** +git checkout+ mit plugin von master
  ** +git +
* erzeuge einen Pipeline-View mit dem Namen _pipe-issumy_ und dem Startpunkt _issumy-stage-commit_

== Iteration 10 - stage-production - Diskussion

* Taggen wann?
* Smoke test?
* Commit id in MANFIEST.MF?
  ** +docker run --rm -ti --name prod-inspect --volumes-from issumy-production:ro ubuntu:14.04.1 bash+
* Commit Stage < 5 min

== Iteration 11 - stage-integration

Annahme::

* Integrationstest benutzt Docker Image (bisher extra Verticle gestartet)
* die Integrationsumgebung wird unter Port 8071 erreichbar sein

Schritte::

* kopiere die +stage-production/build.gradle+ nach +stage-integration/build.gradle+
* kopiere die +stage-production/gradle.properties+ nach +stage-integration/gradle.properties+
* ersetze den String "production" mit "integration" und "Production" mit "Integration"
* benutze für den Container den port 8071 (parent -> child, 8071:8080)
* benutze das _java_ Plugin in gradle
* füge als Repository +mavenCentral()+ ein
* füge folgende Abhängigkeiten ein
----
  testCompile "io.vertx:vertx-core:$vertxVersion"
  testCompile "io.vertx:vertx-platform:$vertxVersion"
  testCompile "junit:junit:$junitVersion"
  testCompile "io.vertx:testtools:$toolsVersion"
----
* mache den Task _test_ abhängig von _deployIntegration_ (+./gradle --dry-run test+ zeigt die Abarbeitungsfolge)
* verschiebe den Test +IssuesViaRestTest+ in dieses Projekt
* Entferne die Initialisierung von +IssuesStarterVerticle+ aus dem Test
* füge einen Jenkins Job _issumy-stage-integration_ zwischen _stage-commit_ und _stage-production_ ein
  ** Umgebungsvariablen nicht vergessen!
  ** automatisch starten nach commit

== Iteration 11 - stage-integration - Diskussion

* Warum kein Unterprojekt im Sinne von gradle?
* Haben wir bisher einen Abbruch in der Pipeline, wenn etwas nicht funktioniert?
* Haben wir bisher Unit Tests?

== Iteration 12 - Unit Test Gate einführen

* benutze das _jacoco_ Plugin in gradle
* schreibe für jede Klasse einen Unit-Test, welcher das erzeugen via Default-Konstruktor testet.
* lasse den _issumy-stage-commit_ stoppen, wenn nicht alle Klassen einen Test haben

== Iteration x - Performance Testing - hands on

* Erzeuge einen http://jmeter.apache.org/usermanual/get-started.html[JMeter] Test der tested ob die Liste der issues innerhalb von 0.3 Sekunden geliefert werden kann
  ** Installiere dazu JMeter
  ** Konfiguriere den Test
  ** Speichere die jmx Datei
* Fuege einen _stage-performance_ dem Projekt hinzu
  ** erstelle eine +build.gradle+ Datei welche
    *** benutze das https://github.com/kulya/jmeter-gradle-plugin[jmeter-gradle-plugin]
    *** einen Container starten und die Tests gegen diesen Container ausführen
* Baue Job in Jenkins und ordne ihn in der richtigen Reihenfolge ein

== Weiterführende Themen

* OpenStack
* Microservices
* Provisioning (Saltstack, Puppet, Chef)
* The ELK Stack (Elasticsearch, Logstash and Kibana)
* . . .

== Abschliessende Gedanken

image::are-you-too-busy-to-improve.png["Too Busy",float="right"]

* Are you too busy?
* Die ist mehr als die Summe aller! Oder: Einer kann nicht *alles* wissen.
* Fange einfach an und erweitere wenn nötig!
* Wähle den Zeitpunkt richtig - der Zeitpunkt mit dem wenigsten Stress!
* Entwickle aus Sicht des Kunden!
  ** Test: Stufe _produktion_ -> _commit_
  ** Implementation: Stufe _commit_ -> _produktion_

== Zusammenfassung

* viele Beriffe besprochen
* git angefasst
* vert.x ausprobiert
* mit gradle gearbeitet
* Jeninks Projekte konfiguriert
* Artefakte in Nexus gespeichert
* Docker Container gebaut und veröffentlicht.
* eine Deployment Pipeline gebaut
