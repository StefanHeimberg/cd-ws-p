Continuous Delivery - Hands on
==============================
:author:    Oliver Nautsch
:backend:   slidy
:imagesdir: images
:icons:

Ziel
----

* eine Deployment Pipeline bauen

Einführung - Begriffe
---------------------

=== Continuous Delivery ===
bezeichnet eine Sammlung von Techniken, Prozessen und Werkzeugen,
die den Softwarelieferprozess verbessern. ... Continuous Delivery
wird primär in der Agilen Softwareentwicklung eingesetzt.
(http://de.wikipedia.org/wiki/Continuous_Delivery[Wikipedia])

Continuous Delivery is a software development discipline
where you build software in such a way that the software
can be released to production at any time.
( http://martinfowler.com/bliki/ContinuousDelivery.html[Martin Fowler] )

=== Deployment Pipeline ===
ist eine Menge von Validierungen, die eine Software auf ihrem Weg zur Veröffentlichung bestehen muss. (Wikipedia)

Einführung - Softwareentwicklungsansätze
----------------------------------------

=== Die Manifeste

[width="100%",cols="^4,^1,^4,^1,^4", options="header"]
|===============================================================================================
|Software Craftsmanship      |    |Agile                       |    |Traditionell
|a community of professionals|over|individuals and interactions|over|processes and tools
|well-crafted software       |over|working software            |over|comprehensive documentation
|productive partnerships     |over|customer collaboration      |over|contract negotiation
|steadily adding value       |over|responding to change        |over|following a plan
|===============================================================================================

=== Principles and Practices / Prinzipien und Praktiken

* Prinzipien: sind dem Anderen übergeordnet
* Praktiken: Techniken, Werkzeuge und Handlungen die bei der Umsetzung der Prinzipien helfen
  ** Beispiel: Scrum vs. Kanban.

Aufgabenstellung
----------------

* ein Bug Tracking Tool - _issumy_
* iterativ entwickeln
* weil wir es alle kennen, oder kennen sollten :)

Git Essentials - Local
----------------------
image::git-logo.png["Git Logo",float="right", link="http://git-scm.com/"]

* +git init+
* +git add <files>+
* +git commit+
* +git reset \-- <files>+
* +git checkout \-- <files>+
* +git status+
* +git log+
Manual::
* +man git-init+
Links::
* Git Buch: http://git-scm.com/book/de
* Visuelle Git Referenz: http://marklodato.github.io/visual-git-guide/index-de.html
* Git CheatSheet: http://ndpsoftware.com/git-cheatsheet.html

Git Essentials - Local - Hands on
---------------------------------

- lege ein Verzeichnis +~/projects/git-ho+ an (+mkdir+, +cd+)
- erzeuge eine Datei +README.asciidoc+ in diesem Verzeichnis und füge den Text "Version 1" und einen Zeilenumbruch ein (+vi+)
- erzeuge ein git repository/git history (+git init+)
- lese output von +git status+
- fuege die Datei zum 'index' hinzu (+git add+)
- +git status+ sagt auch hier was man tuen könnte
- commit in die 'history' fuer diese Datei (+git commit+, erfragt wird +git config+)
- ändere den Inhalt der Datei in dem Du eine Zeile "Version 2" hinzufügst (+vi+)
- mache die Änderung mit der letzten Version in 'history' rückgängig (+git checkout+)
- nochmals die Datei editieren und "Version 3" Zeile hinzufügen
- Datei den 'index' hinzufügen (+git add+)
- 'index' wieder zurücksetzen mit letzter Version in 'history' (+git reset+)
- zum Abschluss noch die History mit allen Änderungen anschauen (+git log+)

Git Essentials - Branching
--------------------------

- +git branch+
  ** erzeugen, auflisten, löschen von Branches
- +git checkout <branch-name>+
  ** wechselt in den branch
  ** setzt _HEAD_ auf den branch
- +git merge+
  ** zusammenführen von Histories
- +git rebase+
  ** erzeugt lineare History in dem Änderungen eines Branches auf einem anderen Branch angewendet werden

Ausflug ins Git-Buch::
- http://git-scm.com/book/de/Git-Branching-Was-ist-ein-Branch%3F[Git Branching - Was ist ein Branch?]

Git Essentials - Branching - Hands on
-------------------------------------

- erzeuge einen neuen Branch "development"
- wechsle auf diesen Branch
- fuege eine neue Zeile mit Text "Branch Development" hinzu
- Änderung commiten
- wechsle in Branch "master"
- kurz anschauen, dass nun in der Datei die gerade gemachte Änderung nicht enhalten ist (z.B. +less README.asciidoc+)
- merge die Änderungen von Branch "development" nun in den Branch "master"
- nun enthält auch der Branch "master" diese Änderung

Git Essentials - Remote
-----------------------

- +git clone+
  ** erzeugt einen Clone eines Repositories in einem neuen Verzeichnis
- +git fetch+
  ** download von Objekten und refs
- +git pull+
  ** fetch und integration in ein anderes Repo oder lokalen Branch
- +git push+
  ** updated remote refs mit lokalen refs indem die notwendigen Objekte geschickt werden


Git Essentials - Remote - hands-on
----------------------------------

- erzeuge ein Verzeichnis +~/git-repos+
- clone +\~/projects/git-ho+ nach +~/git-repos/git-ho.git+ (+git clone \--bare+)
  ** macht ein +git init+ und +git fetch+ ohne eine Arbeitskopie anzulegen
- füge das "Remote-Repository" deinem Lokalen Repository hinzu (+git remote add upstream file://home/dev/git-repos/git-ho.git/+)
- +git remote -v+
- in die Rolle eines 2. Entwickler schlüpfen:
  ** +git clone file:///home/ollin/projects/cd-ws/git-repos/git-ho.git /home/dev/projects/git-ho-dev2+
  ** editiere +README.asciidoc+ in +/home/dev/projects/git-ho-dev2+ (z.B. zusätzliche Zeile "Hallo von Dev2")
  ** commit in History von dev 2
  ** push zum Remote
- wieder in die eigene Rolle schlüpfen
  ** +cd /home/dev/projects/git-ho+
  ** git fetch upstream
  ** git merge upstream/master
  ** fuege eine Zeile "Huhu von Dev1" hinzu und commit, push zu Remote ( -u )
- 2. Entwickler:
  ** +cd /home/dev/projects/git-ho-dev2+
  ** +git pull+
     ** fasst ein _fetch_ und _merge_ zusammen
Optional::
- erzeuge einen Tag "v1" und pushe den Tag ins Remote Repo
- hole den Tag ins lokale Repo des anderen Entwicklers

issumy - Iteration 1
--------------------

- vert.x mit einem "verticle" laufen lassen.

issumy - Iteration 1 - hands-on - install gvm
---------------------------------------------

- installiere GVM the Groovy enVironment Manager http://gvmtool.net/ .

----
~/$curl -s get.gvmtool.net | bash
~/$source "/home/dev/.gvm/bin/gvm-init.sh"
~/$gvm
----

- installiere Gradle http://www.gradle.org/

----
~/$gvm install gradle 2.0
----

- installiere Vert.x http://vertx.io/

----
~/$gvm install vertx 2.1.2
----

- installiere Lazybones Project Creation Tool https://github.com/pledbrook/lazybones

----
~/$gvm install lazybones
----

- erzeuge Projekt mit Schablone aus lazybones

----
~/$mkdir projects && cd projects
~/projects$lazybones create java-basic issumy
~/projects$cd issumy
~/projects/issumy$gradle tasks
----

issumy - Iteration 1 - hands-on - import in IDEA
------------------------------------------------

.Importiere das Projekt in Intellij IDEA
image::iteration1-import-project.png[Import Projekt in IDEA]

issumy - Iteration 1 - hands-on - an example for vert.x
-------------------------------------------------------

[source, Java]
----
package httphelloworld;

/*
 * Copyright 2013 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import org.vertx.java.core.Handler;
import org.vertx.java.core.http.HttpServerRequest;
import org.vertx.java.platform.Verticle;

import java.util.Map;

public class HelloWorldServer extends Verticle {

  public void start() {
    vertx.createHttpServer().requestHandler(new Handler<HttpServerRequest>() {
      public void handle(HttpServerRequest req) {
        req.response().headers().set("Content-Type", "text/plain");
        req.response().end("Hello World");
      }
    }).listen(8080);
  }
}
----
from https://raw.githubusercontent.com/vert-x/vertx-examples/master/src/raw/java/httphelloworld/HelloWorldServer.java

issumy - Iteration 1 - hands-on - running the example for vert.x
----------------------------------------------------------------

- zur Zeit noch keine Abhängigkeiten definiert (Fehler in IDE)
- wir können es auch noch nicht mit gradle bauen
- ... aber vert.x kann schon damit laufen

----
~/projects/issumy$vertx run src/main/java/httphelloworld/HelloWorldServer.java
Succeeded in deploying verticle
----

- öffne den Browser mit +http://localhost:8080/+

.Run Verticle in Browser
image::iteration1-run-helloworld-browser-.png[Run Verticle in Browser]

IMPORTANT: +git commit+

Einführung - vert.x
-------------------
image::vertx-logo.png["Vert.x Logo",float="right", link="http://vertx.io/"]

Vert.x ist ein polyglotes, ereignisorientiertes Anwendungsframework,
das in der Java Virtual Machine läuft.

- Java, JavaScript, Ruby, Python, Groovy, Clojure, Scala
- einfache, mächtige API's zum Schreiben von netzwerkfähigen Appliktationen
- non blocking I/O um viele Verbindungen mit wenigen Threads zu bedienen
- einfaches "actor-like" Programmierungsmodell

Features::

- distributed event bus server to server
- Support für Websockets/SockJS
- einbetten in existierende Java-Applikationen möglich
- Module System via Maven Central, Maven Repository oder Bintray
- Apache Software License 2.0

Einführung - vert.x - Begriffe
------------------------------

- Verticle -- Code welcher von vert.x ausgeführt wird (Vert.x Particle).
- Module   -- eine Vert.x Applikation besteht aus einem oder
mehreren Modulen. Module können mehrere Verticles enthalten. Via modules
kann Funktionalität gekapselt und wiederverwendet werden.
- Concurrency - ein Verticle wird von einem Thread verwendet
- Event Bus - Verticles kommunizieren via dem Event Bus miteinander
- Asynchronous Programming Model - die meiste Zeit werden Event Handler benötigt
- Event Loops - kleine Anzahl von Threads, welche Events an Handler weiterleiten
- Worker Verticles - für blockierenden Code (z.B. JDBC), diese Verticles können
durch unterschiedliche Threads benutzt werden


IMPORTANT: Handler dürfen nicht blockieren

issumy - Iteration 2
--------------------

- einfaches Verticle in Module verpacken

Iteration 2 - Template kopieren
-------------------------------

- clone Template Projekt
- kopiere Notwendiges

[source, bash]
----
~/$cd && cd projects
~/projects$git clone https://github.com/ollin/vertx-gradle-template.git template
~/projects$cp -rf template/gradle issumy/                                     # <1>
~/projects$cp template/build.gradle issumy/                                   # <2>
~/projects$cp template/gradle.properties issumy/
~/projects$cp template/conf.json issumy/                                      # <3>
~/projects$mkdir issumy/src/main/resources/
~/projects$cp template/src/main/resources/mod.json issumy/src/main/resources/ # <4>
~/projects$cp template/gradlew* issumy/                                       # <5>
----
<1> kopiert Gradle Wrapper Libs und Vertx spezifische Build Skripte
<2> kopiert das eigentliche Build Skript und in der nächsten Zeile die Properties zum Build
<3> kopiert Konfigurationsdatei für +gradle runMod+
<4> kopiert die Module-Konfigurationsdatei
<5> kopiert die Gradle Wrapper Skripte

Iteration 2 - +gradle.properties+
---------------------------------

- anpassen der Gradle-Eigenschaften an unser Projekt

[source, conf]
----
# E.g. your domain name
modowner=net.nautsch

# Your module name
modname=issumy

# Your module version
version=0.1-SNAPSHOT

. . .
----


Iteration 2 - +build.gradle+
----------------------------

- anpassen der Artefakt-Eigenschaften an unser Projekt

[source, txt]
----
. . .
def configurePom(def pom) {
  pom.project {
    name rootProject.name
    description 'CH OPEN Workshoptage 2014 - Continuous Delivery - Beispiel Projekt - issumy'
    inceptionYear '2014'
    packaging 'jar'

    url 'https://github.com/ollin/cd-ws-issumy'

    developers {
      developer {
        id 'ollin'
        name 'Oliver Nautsch'
        email 'oliver.nautsch@gmail.com'
      }
    }

    scm {
      url 'https://github.com/ollin/cd-ws-issumy.git'
    }

    licenses {
      license {
        name 'The MIT License (MIT)'
        url 'http://opensource.org/licenses/MIT'
        distribution 'repo'
      }
    }

    properties {
      setProperty('project.build.sourceEncoding', 'UTF8')
    }
  }
}
----

Iteration 2 - running
---------------------

[source, bash]
----
~/projects/issumy$./gradlew tasks

~/projects/issumy$./gradlew fatJar
----
starten via:

[source, bash]
----
~/projects/issumy$java -jar build/libs/issumy-0.1-SNAPSHOT-fat.jar #<1>
----
oder

[source, bash]
----
~/projects/issumy$vertx runzip build/libs/issumy-0.1-SNAPSHOT.zip #<1>
----
oder

[source, bash]
----
~/projects/issumy$VERTX_MODS=./build/mods bash -c 'vertx runmod net.nautsch~issumy~0.1-SNAPSHOT' #<1>
----
oder

[source, bash]
----
~/projects/issumy$./gradlew runMod #<1>
----

<1> öffne Browser http://localhost:8080/ , beenden mit CTRL-C

IMPORTANT: +git commit+

Einführung - Gradle
-------------------
image::gradle-logo.png["Gradle Logo",float="right", link="http://www.gradle.org/"]

* Buildskripte heissen *build.gradle*
* ein Buildskript ist ein Groovy-Skript, welche eine eigene DSL benutzt die erweitert oder angepasst werden kann.
* Gradle kennt Plugins
* Konvention vor Konfiguration (Convention over Configuration)
  ** z.B. verwendet das http://www.gradle.org/docs/current/userguide/java_plugin.html[Java-Plugin] das Standard-Verzeichnis-Layout von Maven
* Zwei Phasen der Abarbeitung
  ** Konfiguration -- in der ein _Directed acyclic graph_ (kurz DAG) erzeugt wird, der alle Build-Schritte enthält
  ** Ausführung -- alle Tasks des DAG werden abgearbeitet, wenn vorgängiger Task erfolgreich war
* sowohl deklarativ als auch imperativer Ansatz möglich
* der Gradle-Wrapper
  ** downloaded Gradle und benutzt diese Version
  ** ideal für Continuous Integration, da keine Installation notwendig ist

issumy - Iteration 3 - Implementiere "liefere Liste"
----------------------------------------------------

* liefere eine Liste von Issues
  ** Annahme: eine Single-Page-Web-App soll geschrieben werden, welche über den EventBus mit dem Server kommuniziert

Iteration 3 - Gradle-Wrapper und Idea
-------------------------------------

image::setting-gradle-wrapper-in-idea.png["Configure Gradle Wrapper in IDEA",float="right"]
- in IDEA -> +File+ -> +Settings+ -> +_gradle_+ (links oben eingeben) -> +Use customizable gradle wrapper+ -> +Apply/Ok+
- IDEA läd nun ein paar Libraries
- erweitere +.gitignore+ wenn notwendig
- ändere Source und Target Version des JDK auf 1.8 in +issumy/gradle/vertx.gradle+
----
...

.idea/
*.iml
----
- Run/Debug aus IDEA
  ** +File+ -> +Project Structure+ -> +Modules+ -> +Dependencies+ -> ändere "provided" in "compile" -> +Ok+
  ** +Run+ -> +Run. . .+ -> +Edit Configurations+ -> + -> +Application+
     *** Name: +vertx runMod issumy+
     *** Main class: +org.vertx.java.platform.impl.cli.Starter+
     *** Program arguments: +runmod net.nautsch\~issumy\~0.1-SNAPSHOT -cp ./build/mods/net.nautsch\~issumy~0.1-SNAPSHOT/+
     *** Working directory: +/home/dev/projects/issumy+
     *** Use classpath of module: +issumy+
     *** +Run+
     *** In der Console muss nun _INFO: Succeeded in deploying module_ erscheinen.
     *** Browser öffnen und +localhost:8080+ liefert wieder _Hello World_


Iteration 3 - Beispiel Programmieren
------------------------------------

* Test
  ** +com.inventage.issumy.issues.test.integration.IssuesViaEventBusTest+
  ** leitet von der abstrakten Klasse +TestVerticle+ ab
  ** überschreibt +start+ um via +container.deployVerticle()+ das Verticle +com.inventage.issumy.issues.IssuesVerticle+ zu deployen
  ** implementiert eine Methode +shouldReturnEmptyListOfIssues+ welche via dem vertx eventBus eine Nachricht an die Adresse +_com.inventage.issumy.issues_+ schickt
     und via einem _replyHandler_ prüft ob ein JsonArray (ist eine vertx-Klasse) mit der Grösse "0" ankommt.

* Implementierung
  ** +com.inventage.issumy.issues.IssuesVerticle+
  ** leitet von der abstrakten Klasse +Verticle+ ab
  ** registriert einen Handler auf dem vertx EventBus mit der Adresse +_com.inventage.issumy.issues_+ welcher einen leeren JsonArray zurückschickt.

Iteration 3 - Beispiel für Test
-------------------------------

[source, java]
----
package com.inventage.issumy.issues.test.integration;

import com.inventage.issumy.issues.IssuesVerticle;
. . .

/**
 * integration test.
 */
public class IssuesViaEventBusTest extends TestVerticle {

    @Test
    public void shouldReturnEmptyListOfIssues() throws Exception {
        // when
        vertx.eventBus().send("com.inventage.issumy.issues", "", (Message<JsonArray> msg) -> {
            // then
            assertThat(msg.body().size(), is(0));
            testComplete();
        });
    }

    @Override
    public void start() {
        initialize();

        container.deployVerticle(IssuesVerticle.class.getName(), event -> {
            if (event.failed()) {
                throw new IllegalStateException("deployment of module failed", event.cause());
            }
            startTests();
        });
    }
}
----

Iteration 3 - Beispiel für Implementierung
------------------------------------------
[source, java]
----
package com.inventage.issumy.issues;

import org.vertx.java.core.json.JsonArray;
import org.vertx.java.platform.Verticle;

/**
 * verticle handles issues.
 */
public class IssuesVerticle extends Verticle {

    @Override
    public void start() {
        vertx.eventBus().registerHandler("com.inventage.issumy.issues", event -> {
            event.reply(new JsonArray());
        });

        container.logger().info("IssuesVerticle started");
    }
}
----

* +./gradlew test+
* commit
* erzeuge remote repository mit +file://+ Protokoll unter ~/repos/
  * da

Einführung - Continous Integration
----------------------------------

http://www.martinfowler.com/articles/continuousIntegration.html[nach Martin Fowler]

* Gemeinsame Codebasis
* Automatisierte Übersetzung
* Kontinuierliche Test-Entwicklung
  ** Test zusammen mit Produktionscode entwickeln
  ** Code Coverage
* Häufige Integration des Codes jedes Entwicklers in den Hauptentwicklungszweig
* Schneller Build und schnelle Test für schnelles Feedback
* Gespiegelte Produktionsumgebung
* Einfacher Zugriff auf Ergebnisse
* Automatisiertes Reporting
* Automatisierte Verteilung

http://de.wikipedia.org/wiki/Kontinuierliche_Integration[Siehe auch Wikipedia - Kontinuierliche Integration]

Einführung - Jenkins
--------------------
image::jenkins_logo.png["Jenkins Logo",float="right", link="http://jenkins-ci.org/"]
Jenkins ist ein erweiterbares, webbasiertes System zur kontinuierlichen Integration. (Siehe http://de.wikipedia.org/wiki/Jenkins_(Software)[Wikipedia])

Begriffe::
* Jobs (Projects)
* Steps
* Post-build Actions
* Views
* https://wiki.jenkins-ci.org/display/JENKINS/Building+a+software+project#Buildingasoftwareproject-JenkinsSetEnvironmentVariables[Environment Variable]
* https://wiki.jenkins-ci.org/display/JENKINS/Plugins[Plugin]
  ** Beispiele:
     *** https://wiki.jenkins-ci.org/display/JENKINS/Conditional+BuildStep+Plugin[Conditional BuildStep Plugin]
     *** https://wiki.jenkins-ci.org/display/JENKINS/Git+Plugin[Git Plugin]

issumy - Iteration 4 - automatisiertes Testen
---------------------------------------------

* automatisiere das Testen mit Jenkins
  ** Plugins installieren
  ** Job/Projekt erzeugen

Iteration 4 - Anlegen eines Jobs
--------------------------------

* Jenkins Admin Konsole im Browser öffnen: http://localhost:8180 (im Firefox ist auch ein Bookmark)
* installiere Jenkins-Plugins:
  ** "SafeRestart Plugin"
  ** "Git Plugin"
  ** "Gradle plugin"
* erzeuge ein free-style software project "issumy-stage-commit"
  ** Source Code Mangement - Git
     *** checkout von +file:///home/dev/repos/issumy.git+
     *** baue von refs/heads/master
  ** Rufe das Gradle Script auf
     *** benutze den Gradle Wrapper
     *** Task: _test_
* Job laufen lassen
  ** via Button im GUI
  ** via URL im Browser ( http://localhost:8180/job/issumy-stage-commit/build )
  ** via URL auf Command Line ( +curl http://localhost:8180/job/issumy-stage-commit/build+ )

Einführung - Nexus
------------------

Nexus ist ein Software Repository Manager. Ein Softwarerepository ist ein Speicherort von
welchen man Softwarepakete beziehen kann. Es enthält neben den Programmpaketen auch Metadaten über diese.

Begriffe::
* Repository
  ** Hosted
  ** Proxy
  ** Group
* User
* Rollen


issumy - Iteration 5 - Artefakte speichern
------------------------------------------

* liefere die Artefakte von _issumy_ ins Repository "Snapshots"
notwendige Schritte:
* anmelden in Nexus ( http://localhost:8181/nexus user: +admin+ password: +admin123+ )
* finde die URL's fuer die Repositories
  ** Release
  ** Snapshot
* setze Passwort fuer User "deployment" auf "deployment9"
* erzeuge einen Task "uploadArchives" in gradle am Ende von +build.gradle+
* commit / push
* erzeuge in Jenkins einen neuen "build step" innerhalb von "issumy-stage-commit"
  ** mit gradle wrapper
  ** und task "uploadArchives"
* Job starten
* Nexus - Inhalt von Repository "Snapshots" prüfen

Iteration 5 - uploadArchives
----------------------------

[source, txt]
----
...
uploadArchives {
    repositories {
        mavenDeployer {
            repository(url: "<url von "Releases">") {
                authentication(
                        userName: "deployment",
                        password: "deployment9"
                )
            }
            snapshotRepository(url: "<url von "Snapshots">") {
                authentication(
                        userName: "deployment",
                        password: "deployment9"
                )
            }
        }
    }
}
----

Iteration 5 - Diskussion
------------------------

* URLs
  ** +http://localhost:8181/nexus/content/repositories/releases/+
  ** +http://localhost:8181/nexus/content/repositories/snapshots/+
* Warum sollte man die Passwörter aus +build.gradle+ auslagern?
* Wie finde komme ich selber auf die Lösung von "uploadArchives"?
  ** Dokumentation Maven Plugin ( http://www.gradle.org/docs/current/userguide/maven_plugin.html#uploading_to_maven_repositories )
  ** DSL Reference ( http://www.gradle.org/docs/current/dsl/ )
* "... can be released to production at any time." -> also jeder Commit.
* Automate everything!

== issumy - Iteration 6 - Hooks

* automatisiere das Starten des Jenkins Jobs bei jedem Commit
* benutze dazu "Hooks" von git

empfohlenes Vorgehen::
* das Git-Plugin von Jenkins unterstützt spezielle URL's um Jobs zu starten welche das Repository benutzen
  ** finde heraus, wie diese aussehen
  ** benutze die Url via CLI (wenn +Scheduled polling of issumy-stage-commit+ zu sehen ist, dann ist die URL und Konfiguration in Jenkins richtig)
     *** Polling in Jenkins ohne Schedule muss aktiviert sein
     *** Der Job startet nur, wenn wirklich eine Änderung im Repository gemacht wurde
* Git stellt clientseitige und serverseitige Hooks zur Verfügung
  ** finde den Hook der ausgeführt wird, wenn der _push_ auf dem Server erfolgreich war
  ** erzeuge die entsprechende Datei und mache sie mit chmod +x ausführbar

== Iteration 6 - Lösungsbeispiel

image::jenkins-git-poll.png["Poll markieren",float="right"]

Datei: +/home/dev/repos/issumy.git/hooks/post-receive+

[source, bash]
----
#!/bin/bash
curl http://localhost:8180/git/notifyCommit?url=file:///home/dev/repos/issumy.git

----

IMPORTANT: +chmod +x /home/dev/repos/issumy.git/hooks/post-receive+

== Iteration 6 - Diskussion

* Warum ist der Hook via Repository besser als via Projektnamen?

nächster Schritt::

* Gespiegelte Produktionsumgebung

== Einführung - Docker

image::docker_logo.png["Docker Logo",float="right", link="https://www.docker.com/"]

Docker is an open platform for developers and sysadmins to build, ship, and run distributed applications.

Bestandteile::

* https://docs.docker.com/installation/ubuntulinux/[Docker Engine]
* https://hub.docker.com/[Docker Hub]

Techniken::

* cgroups - control groups - Linux Kernel Funktion zum begrenzen, messen und isolieren von
  Ressourcen (CPU, Speicher, disc I/O etc.)
* kernel namespaces - trennen der Sichtbarkeit von Ressourcen
  in anderen Gruppen (Prozesse, Netzwerk, user IDs, Dateisysteme, etc.)
* Overlay-Dateisystem (AuFS oder Btrfs)

Wer steht hinter Docker::

* die Firma Docker (Anfangs Jahr 15 Millionen US-Doller erhalten)
* Red Hat integriert Docker in Red Hat Enterprise Linux 7 und will Container zertifizieren
* Google, Microsoft, Red Hat, IBM, Docker, Mesosphere, CoreOS und SaltStack
  arbeiten am https://github.com/GoogleCloudPlatform/kubernetes[Kubernetes Projekt] mit.

Begriffe::

* Image
* Container
* Registry
  * Hub
  * local eigene

== Docker Kommandos

image::dockerstory.png["Docker Story",float="right"]

* +man docker+

* +docker images+    listed die Images auf
* +docker run+       führt ein Kommando in einem neuen Container aus
* +docker stop+      stopt einen Container
* +docker start+     startet einen Container
* +docker ps+        listed die Container auf
* +docker rm+        löscht Container

* +docker build+     erzeugt ein neues Image aus einem _Dockerfile_
* +docker pull+      zieht ein Image oder Repository von Registry
* +docker push+      schiebt ein Image oder Repository zur Registry
* +docker rmi+       löscht Image

* +docker inspect+   Infos über Container oder Images

== Iteration 7 - Erzeugen eines Containers

== Iteration 8 - Erzeugen eines Image

erzeuge +~/projects/docker-test/Dockerfile+

[source, txt]
----
FROM ubuntu:14.04.1
MAINTAINER Oliver Nautsch <oliver.nautsch@gmail.com>

RUN touch huschihops.txt
----

+docker build -t inventage/huschi_hops:1.0 .+

== Einführung - Eigene Docker Registry

[source, bash]
----
docker run -p 5000:5000 -dt --name registry registry
docker run -d -p 8080:8080 --name registry-ui atcol/docker-registry-ui
docker ps
----

* nun kann man den Browser mit +http://localhost:8080/+ öffnen
  und die Applikation _Docker Registry Web_ sehen

== Iteration 9 - Veröffentlichen eines Images

* Konfiguriere das Repository, welches auf Port 5000 im docker-host läuft
  im _Docker Registry Web_
  * benutze +ifconfig+ im docker host um die richtige IP-Adresse zu finden
* tagge die das Image für das lokale Repository mit +1.0+ und +latest+
* und schiebe die Images ins lokale Repo
* prüfe das Ergebnis im _Docker Registry Web_

[source, bash]
----
docker tag inventage/huschi_hops:1.0 localhost:5000/inventage/huschi_hops:1.0
docker tag inventage/huschi_hops:1.0 localhost:5000/inventage/huschi_hops:latest
docker images #zeigt nun schön, dass alle tags auf die gleiche image id zeigen

docker push localhost:5000/inventage/huschi_hops:1.0
docker push localhost:5000/inventage/huschi_hops:latest
----



Zusammenfassung
---------------

* git angefasst
* vert.x ausprobiert
* mit gradle gearbeitet
* Jeninks Projekte konfiguriert
* eine Deployment Pipeline gebaut
