= Continuous Delivery
Oliver Nautsch <oliver.nautsch@nautsch.com>
2016
:author:    Oliver Nautsch
ifndef::imagesdir[:imagesdir: images]
:menu:
:goto:
:scale:
:help:
:toc:
:status:
:blank:

== Zur Person

Oliver Nautsch +
_Software Crafter_ (Engineering, Coaching, Consulting) +
Nautsch GmbH | Im oberen Boden 1 | 8049 Zürich

* Well rounded fullstack Java (Kotlin), JavaScript, HTML, SQL, ...
* Microservices, CD, TDD, Build Tools, DB, Docker, Linux, ...
* Coaching, Cultural Change, DevOps, ...
* Von Startups bis Big Enterprise
* Finanzindustrie, Bildungsumfeld

'''

email:      oliver.nautsch@nautsch.com +
twitter:    https://twitter.com/ollispieps[@ollispieps] +
github:     https://github.com/ollin[@ollin] +
google+:     https://plus.google.com/+OliverNautsch/[OliverNautsch] +


'''
Vorsitzender des Vorstandes der http://jug.ch[Java User Group Switzerland] +
Co-Organisator http://socrates-day.ch/[SoCraTes Day Switzerland] 2015 und 2016


== Ziel

_Einführung in CD_

* Antworten – fragt bitte jederzeit
* Begriffe – die wichtig sind
* Werkzeuge - die man gebrauchen kann
* Pipeline - als Beispiel

== Das Projekt

* _cd-ws-address_ - ein Adressverwaltungssystem
* iterativ entwickeln

== Git

image::git.png[Git,150,150,float="right"]

* Verteilte Versionsverwaltung von Dateien


== Gradle

image::gradlephant.png[Gradle,150,150,float="right"]


== HandsOn 1:

. Linux in Virtualbox gestartet
. Projekt cd-ws-address gebaut
. Server gestartet
. Ergebniss des Servers in Browser oder via http angeschaut
. optional
.. Projekt in Intellij Idea importieren)

== Erläuterung zu HandsOn 1

image::keyboard-layout-applet.png[Keyboard Layout,,,float="right"]

. Einloggen in Linux Guest innerhalb Virtualbox (`dev`, `dev123`)
.. rechts unten im Panel ist ein Applet zur Auswahl des Tastaturlayouts
. Starten des Teminal progammes

[source,bash]
----
dev@vagrant:~$ cd /home/dev/cd-ws-address/      // <1>
dev@vagrant:~/cd-ws-address$ git pull           // <2>
dev@vagrant:~/cd-ws-address$ ./gradlew sync01   // <3>
dev@vagrant:~/cd-ws-address$ ./gradlew build    // <4>
dev@vagrant:~/cd-ws-address$ java -jar workspace/build/libs/address-0.0.1.jar // <5>
----
<1> Wechsel ins Projektverzeichnis
<2> Aktualisieren des Projekten von github
<3> erste Uebung in den Workspace kopieren
<4> bauen des Projektes
<5> starten des servers

[start=3]
. zweites Terminal starten


[source,bash]
----
$ http http://localhost:8080/
----

== Continous Integration

http://www.martinfowler.com/articles/continuousIntegration.html[nach Martin Fowler]

* Gemeinsame Codebasis
* Automatisierte Übersetzung
* Kontinuierliche Test-Entwicklung
  ** Test zusammen mit Produktionscode entwickeln
  ** Code Coverage
* Häufige Integration des Codes jedes Entwicklers in den Hauptentwicklungszweig
* Schneller Build und schnelle Test für schnelles Feedback
* Gespiegelte Produktionsumgebung
* Einfacher Zugriff auf Ergebnisse
* Automatisiertes Reporting
* Automatisierte Verteilung

http://de.wikipedia.org/wiki/Kontinuierliche_Integration[Siehe auch Wikipedia - Kontinuierliche Integration]

== Gogs

image::gogs.png[Gogs,,,float="right"]

* Git-Repository-Verwaltung
** Issue-Verwaltung
** Issues
** Git Hooks
** ...

== HandsOn 2

* Erzeugen eines zentralen Repository in Gogs

== Erläuterung zu HandsOn 2

. Anmelden in Gogs

[width=50,cols="1,1"]
|====
| URL:  | http://git.nautsch.net
| User: | `dev`
| PW:   | `dev123`
|====

[start=2]
. Erzeugen eines Repository mit dem Namen _cd-ws-address_
. Terminal (mit Ctrl-C Server stoppen)

[source,bash]
----
$ cd /home/dev/cd-ws-address/
$ git config --global user.email "dev@example.com"  # <1>
$ git config --global user.name "dev"               # <2>
$ git remote add upstream http://git.nautsch.net/dev/cd-ws-address.git # <3>
$ git add -A && git commit -m "handson 01 in workspace" # <4>
$ git push -u upstream master # <5>
----

<1> setze globale email
<2> setze usernamen ueber alle Projekte
<3> gogs als remote repository unter dem Namen _upstream_ hinzufügen
<4> füge den Sync in den Workspace (Siehe HandsOn 1) dem Repository hinzu
<5> code zu gogs push'en und den lokalen branch mit gogs verbinden (`-u`)

== Jenkins

== HandsOn 3

* Job in Jenkins anlegen
* verbinden mit zentralen Repo in Gogs

== Erläuterung zu HandsOn 3

[start=2]
. Browser öffnen -> http://ci.nautsch.net
. Job anlegen
.. "New Item"
.. "Enter an item name" -> `handson_3`
.. "Free Style Project" -> "Ok"
.. Source Code Management
... git
... Repository URL -> `http://git.nautsch.net/dev/cd-ws-address.git`
.. Build Triggers
... Poll SCM
... Schedule leer lassen
.. Add build step
... Invoke Gradle script
... Use Gradle Wrapper
... From Root Build Script Dir (Haken wegnehmen)
... Root Build script -> `${workspace}/workspace/`
... Tasks -> `build`
... Save
.. Build Now

== Hooks

* automatisiere das Starten des Jenkins Jobs bei jedem Commit
** keine Scheduled Builds! (erzeugt unnötig Last)
* benutze dazu "Hooks" von git
* das Git-Plugin von Jenkins unterstützt spezielle URL's um Jobs zu starten welche das Repository benutzen
  ** +http://<ciserver>/git/notifyCommit?url=<eingetragenes repository>+

== Erläuterung zu HandsOn 4

. benutze die Url via CLI zum testen
[source, bash]
----
curl http://ci.nautsch.net/git/notifyCommit?url=http://git.nautsch.net/dev/cd-ws-address.git
----
[start=2]
. wenn +Scheduled polling of handson_3+ zu sehen ist, dann ist die URL und Konfiguration in Jenkins richtig)

IMPORTANT: Job läuft aber nicht an (kein Änderung in git)

[start=3]
. nun hook von git in Gogs eintragen ( http://git.nautsch.net/dev/cd-ws-address )
.. Settings -> Git Hooks -> _post-receive_ -> Edit
.. Hook Content:

[source,bash]
----
#!/bin/bash
curl http://ci.nautsch.net/git/notifyCommit?url=http://git.nautsch.net/dev/cd-ws-address.git
#
----

[start=4]
. Fuege lokal im workspace eine Datei hinzu,
. add und commit ins lokale Repo und
. push zum Remote

[source,bash]
----
$ cd /home/dev/cd-ws-address/workspace/
$ touch neuedatei.txt
$ git add -A && git commit -m "handson 04 via git hook"
$ git push
----



== Was ist...

=== Continuous Delivery ===

* Sammlung von Techniken, Prozessen und Werkzeugen, die den Softwarelieferprozess verbessern. ...
* agile Softwareentwicklung
* DevOps
* Release in Produktion zu jeder Zeit möglich <- -> jeder Commit ist ein potentieller Release

( Siehe auch bei http://de.wikipedia.org/wiki/Continuous_Delivery[Wikipedia] und bei http://martinfowler.com/bliki/ContinuousDelivery.html[Martin Fowler] )

=== Deployment Pipeline ===

* Menge von Validierungen, die eine Software auf ihrem Weg zur Veröffentlichung bestehen muss. (Wikipedia)

== Wo kann man CD anwenden

* Applikation
* Datenbank
* Infrastruktur

== Warum?

* Weniger Nacharbeiten
* Mehr Automatisierung
* Weniger Riskio bei Auslieferung
* Mehr Durchsatz bei höherer Stabilität
* Weniger Fehler bei Änderungen
* Fehler einfacher zu finden
* Schnellere Reaktionszeit



== Schranken

[cols="4,^1,^1,^1,^1,^1,^1"]
|=========================================================
| ->                                    |Commit    | AAT      | Expl.T   | UAT      | Pre-Prod | Prod
| Syntax Check                          |  X       |     _    |     _    |     _    |     _    |  _
| Unit Tests                            |  X       |     _    |     _    |     _    |     _    |  _
| Compile                               |  X       |     _    |     _    |     _    |     _    |  _
| Code Metrics                          |  X       |     _    |     _    |     _    |     _    |  _
| Story Level Tests                     |     _    |  X       |     _    |     _    |     _    |  _
| Integration Tests                     |     _    |  X       |     _    |     _    |     _    |  _
| BDD Tests                             |     _    |  X       |     _    |     _    |     _    |  _
| Component Tests                       |     _    |  X       |     _    |     _    |     _    |  _
| Feature-Level Testing                 |     _    |  X       |     _    |     _    |     _    |  _
| Visual Tests                          |     _    |     _    |  X       |     _    |     _    |  _
| Usability Tests                       |     _    |     _    |  X       |     _    |     _    |  _
| Showcases                             |     _    |     _    |     _    | X        |     _    |  _
| Feature-Level Testing beim Kunden     |     _    |     _    |     _    | X        |     _    |  _
| Performance Tests                     |     _    |     _    |     _    |     _    |  X       |  _
| Network Tests                         |     _    |     _    |     _    |     _    |  X       |  _
| Capacity Tests                        |     _    |     _    |     _    |     _    |  X       |  _
| Smoke Tests                           |     _    |     _    |     _    |     _    |  X       |  X
| Post-Deployment-Tests                 |     _    |     _    |     _    |     _    |  X       |  X
| Rollback & Redeploy                   |     _    |     _    |     _    |     _    |  X       |  X
| Ongoing Live Tests                    |     _    |     _    |     _    |     _    |     _    |  X
|=========================================================

* AAT -- Automated Acceptance Testing
* Expl.T -- Exploratory Testing
* UAT -- User Acceptance Testing
* Pre-Prod -- Pre-Production
* Prod -- Production

